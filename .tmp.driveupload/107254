https://algo.itcharge.cn/

## Array/String

| Number                                                                                                                                      | Problem                                   | Comment                                                                                                                                                                            | Topic                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | Challenge | 熟悉度   |
| ------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | --------- | ----- |
| 1                                                                                                                                           | 2 sum                                     |                                                                                                                                                                                    | hash                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | easy      |       |
| 15                                                                                                                                          | 3 sum                                     |                                                                                                                                                                                    | array/two pointer                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | medium    |       |
| [88. Merge Sorted Array](https://leetcode.com/problems/merge-sorted-array/)                                                                 | merge sorted array                        | 1. Time O(m + n)<br>2. Space O(1) - in-place change<br>3. Start from end so that do not need to shift the arrary<br>4. Edge case, 哪个array厉遍完成就意味着这个array里面的所有item都被另外一个array里面剩下的大 | Array, three pointer                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | easy      |       |
| [27. Remove Element](https://leetcode.com/problems/remove-element/)                                                                         | Remove Element                            |                                                                                                                                                                                    | array/two pointer                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | easy      |       |
| [26. Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/)                               | Remove duplicates from sorted arrary      |                                                                                                                                                                                    | array/two pointer                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | easy      |       |
| [169. Majority Element](https://leetcode.com/problems/majority-element/)                                                                    | Majority Element                          |                                                                                                                                                                                    | [Array](https://leetcode.com/tag/array/)[Hash Table](https://leetcode.com/tag/hash-table/)[Divide and Conquer](https://leetcode.com/tag/divide-and-conquer/)[Sorting](https://leetcode.com/tag/sorting/)[Counting](https://leetcode.com/tag/counting/)                                                                                                                                                                                                                                                                                                                                                                                                                                     | easy      |       |
| [189. Rotate Array](https://leetcode.com/problems/rotate-array/)                                                                            | Rotate Array                              | 注意<br>1. rotate和array长度比较<br>2. 取余数来进行rotate<br>3. 使用temp来保证原来记录                                                                                                                   | [Array](https://leetcode.com/tag/array/)[Math](https://leetcode.com/tag/math/)[Two Pointers](https://leetcode.com/tag/two-pointers/)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | easy      | False |
| [80. Remove Duplicates from Sorted Array II](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/)                         | Remove duplicates from sorted arrary - II |                                                                                                                                                                                    | [Array](https://leetcode.com/tag/array/)[Two Pointers](https://leetcode.com/tag/two-pointers/)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | medium    |       |
| [121. Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)                                      |                                           |                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | easy      |       |
| [122. Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/)                                |                                           |                                                                                                                                                                                    | [Array](https://leetcode.com/tag/array/)[Dynamic Programming](https://leetcode.com/tag/dynamic-programming/)[Greedy](https://leetcode.com/tag/greedy/)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | medium    |       |
| [55. Jump Game](https://leetcode.com/problems/jump-game/)                                                                                   |                                           |                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | medium    |       |
| [45. Jump Game II](https://leetcode.com/problems/jump-game-ii/)                                                                             |                                           |                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | medium    | False |
| [274. H-Index](https://leetcode.com/problems/h-index/)                                                                                      |                                           |                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | medium    | False |
| [380. Insert Delete GetRandom O(1)](https://leetcode.com/problems/insert-delete-getrandom-o1/)                                              |                                           |                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | medium    | True  |
| [238. Product of Array Except Self](https://leetcode.com/problems/product-of-array-except-self/)                                            |                                           |                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | medium    | False |
| [134. Gas Station](https://leetcode.com/problems/gas-station/)                                                                              |                                           |                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | medium    |       |
| [135. Candy](https://leetcode.com/problems/candy/)                                                                                          |                                           |                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | hard      | True  |
| [42. Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/)                                                               |                                           | 画图                                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | hard      | True  |
| [13. Roman to Integer](https://leetcode.com/problems/roman-to-integer/)                                                                     |                                           | 规律 +还是减，和前一个比还是和后一个比                                                                                                                                                               |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | easy      |       |
| [12. Integer to Roman](https://leetcode.com/problems/integer-to-roman/)                                                                     |                                           |                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |           |       |
| [14. Longest Common Prefix](https://leetcode.com/problems/longest-common-prefix/)                                                           |                                           | 记住考虑最短的string的prefix                                                                                                                                                               |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | easy      | True  |
| [151. Reverse Words in a String](https://leetcode.com/problems/reverse-words-in-a-string/)                                                  |                                           | list的操作<br>1. lsitp[::-1]就是reverse                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |           |       |
| [28. Find the Index of the First Occurrence in a String](https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/) |                                           |                                                                                                                                                                                    | **Systematic Approach to Finding Edge Cases:**<br><br>Here's a method to systematically identify edge cases. Ask yourself these questions:<br><br>1. **Size Questions:**<br>    - What if input strings are empty?<br>    - What if one string is longer than the other?<br>    - What if strings are of equal length?<br>2. **Content Questions:**<br>    - What if strings contain repeated characters?<br>    - What if strings are identical?<br>    - What if one string is a subset of another?<br>3. **Boundary Questions:**<br>    - What happens at the start of the string?<br>    - What happens at the end of the string?<br>    - What if the pattern appears multiple times? |           |       |
| [125. Valid Palindrome](https://leetcode.com/problems/valid-palindrome/)                                                                    |                                           |                                                                                                                                                                                    | Two Pointer                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |           |       |
| [209. Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/)                                                  |                                           | 1. 先添加或者删减item，然后再移动index<br>2. fix size, 用if 判断window size 是否>= fix size, 从而滑动左边<br>3. not fix size，用while - ```<br>while 窗口需要缩小，再向左滑动                                            | - sliding window<br>- Subarray vs Subsequence: A subarray must be continuous, while a subsequence can skip elements                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |           |       |
|                                                                                                                                             |                                           |                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |           |       |


# 数组排列

|            | 定义                                                                                                                                            | 复杂度                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | 实现                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| ---------- | --------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| # 冒泡排序     | > **冒泡排序（Bubble Sort）基本思想**：<br>> <br>> 经过多次迭代，通过相邻元素之间的比较与交换，使值较小的元素逐步从后面移到前面，值较大的元素从前面移到后面。<br><br>这个过程就像水底的气泡一样从底部向上「冒泡」到水面，这也是冒泡排序法名字的由来。 | - **最佳时间复杂度**：O(n)O(n)。最好的情况下（初始时序列已经是升序排列），只需经过 11 趟排序，总共经过 nn 次元素之间的比较，并且不移动元素，算法就可以结束排序。因此，冒泡排序算法的最佳时间复杂度为 O(n)O(n)。<br>- **最坏时间复杂度**：O(n2)O(n2)。最差的情况下（初始时序列已经是降序排列，或者最小值元素处在序列的最后），则需要进行 nn 趟排序，总共进行 ∑i=2n(i−1)=n(n−1)2∑i=2n​(i−1)=2n(n−1)​ 次元素之间的比较，因此，冒泡排序算法的最坏时间复杂度为 O(n2)O(n2)。<br>- **空间复杂度**：O(1)O(1)。冒泡排序为原地排序算法，只用到指针变量 ii、jj 以及标志位 flagflag 等常数项的变量。<br>- **冒泡排序适用情况**：冒泡排序方法在排序过程中需要移动较多次数的元素，并且排序时间效率比较低。因此，冒泡排序方法比较适合于参加排序序列的数据量较小的情况，尤其是当序列的初始状态为基本有序的情况。<br>- **排序稳定性**：由于元素交换是在相邻元素之间进行的，不会改变相等元素的相对顺序，因此，冒泡排序法是一种 **稳定排序算法**。                                                                                                                                                                                                                           | 需要两loop，<br>- 第一个是保证每个item都被检查，<br>- 第二个loop是比较还没冒泡剩下的item                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| # 选择排序     | **选择排序（Selection Sort）基本思想**：<br><br>将数组分为两个区间：左侧为已排序区间，右侧为未排序区间。每趟从未排序区间中选择一个值最小的元素，放到已排序区间的末尾，从而将该元素划分到已排序区间。                               | - **时间复杂度**：O(n2)O(n2)。排序法所进行的元素之间的比较次数与序列的原始状态无关，时间复杂度总是 O(n2)O(n2)。<br>    <br>    - 这是因为无论序列中元素的初始排列状态如何，第 ii 趟排序要找出值最小元素都需要进行 n−in−i 次元素之间的比较。因此，整个排序过程需要进行的元素之间的比较次数都相同，为 ∑i=2n(i−1)=n(n−1)2∑i=2n​(i−1)=2n(n−1)​ 次。<br>- **空间复杂度**：O(1)O(1)。选择排序算法为原地排序算法，只用到指针变量 ii、jj 以及最小值位置 min‾imin​i 等常数项的变量。<br>    <br>- **选择排序适用情况**：选择排序方法在排序过程中需要移动较多次数的元素，并且排序时间效率比较低。因此，选择排序方法比较适合于参加排序序列的数据量较小的情况。选择排序的主要优点是仅需要原地操作无需占用其他空间就可以完成排序，因此在空间复杂度要求较高时，可以考虑选择排序。<br>    <br>- **排序稳定性**：由于值最小元素与未排序区间第 11 个元素的交换动作是在不相邻的元素之间进行的，因此很有可能会改变相等元素的相对顺序，因此，选择排序法是一种 **不稳定排序算法**。                                                                                                                                                                                                     | - **Outer Loop (for current_position)**<br>    - Type: For loop through index<br>    - Reason: We need to process each position in the array exactly once<br>    - Boundary: `len(numbers) - 1` because:<br>        - The last element will automatically be in the correct position<br>        - When n-1 elements are sorted, the nth element must be in the right place<br>- **Inner Loop (for search_position)**<br>    - Type: For loop through index<br>    - Reason: We need to examine each unsorted element to find the minimum<br>    - Starting point: `current_position + 1` because:<br>        - Elements before current_position are already sorted<br>        - We start searching from the next element |
| # 03. 插入排序 | **插入排序（Insertion Sort）基本思想**：<br><br>将数组分为两个区间：左侧为有序区间，右侧为无序区间。每趟从无序区间取出一个元素，然后将其插入到有序区间的适当位置。                                                | ##  [插入排序算法分析](https://algo.itcharge.cn/01.Array/02.Array-Sort/03.Array-Insertion-Sort/#_4-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90)<br><br>- **最佳时间复杂度**：O(n)O(n)。最好的情况下（初始时区间已经是升序排列），每个元素只进行一次元素之间的比较，因而总的比较次数最少，为 ∑i=2n1=n−1∑i=2n​1=n−1，并不需要移动元素（记录），这是最好的情况。<br>- **最差时间复杂度**：O(n2)O(n2)。最差的情况下（初始时区间已经是降序排列），每个元素 nums[i]nums[i] 都要进行 i−1i−1 次元素之间的比较，元素之间总的比较次数达到最大值，为 ∑i=2n(i−1)=n(n−1)2∑i=2n​(i−1)=2n(n−1)​。<br>- **平均时间复杂度**：O(n2)O(n2)。如果区间的初始情况是随机的，即参加排序的区间中元素可能出现的各种排列的概率相同，则可取上述最小值和最大值的平均值作为插入排序时所进行的元素之间的比较次数，约为 n244n2​。由此得知，插入排序算法的平均时间复杂度为 O(n2)O(n2)。<br>- **空间复杂度**：O(1)O(1)。插入排序算法为原地排序算法，只用到指针变量 ii、jj 以及表示无序区间中第 11 个元素的变量等常数项的变量。<br>- **排序稳定性**：在插入操作过程中，每次都讲元素插入到相等元素的右侧，并不会改变相等元素的相对顺序。因此，插入排序方法是一种 **稳定排序算法**。 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |

## 双指针和滑动窗口的关系
首先，让我们明确两者的定义：

双指针（Two Pointers）是一种使用两个指针来遍历数组或链表的技术。这两个指针可以：

1. 从数组的同一端开始移动（同向双指针）
2. 从数组的两端向中间移动（对撞双指针）
3. 在不同的数组或链表上移动（并行双指针）

滑动窗口（Sliding Window）是双指针的一种特殊形式。它使用两个指针形成一个"窗口"，这个窗口在数组上滑动。这两个指针总是同向移动，且:

1. 保持相对顺序（右指针永远在左指针右边）
2. 维护一个连续的区间
3. 通常用于求解连续子数组/子串的问题

让我通过一个表格来展示它们的区别和特点：

|特征|双指针|滑动窗口|
|---|---|---|
|指针移动方式|可以同向移动、相向移动、或在不同数组上移动|只能同向移动，且保持先后顺序|
|覆盖范围|可以不连续|必须是连续的区间|
|典型应用场景|1. 两数之和（排序数组）<br>2. 链表中点查找<br>3. 数组去重<br>4. 判断回文|1. 连续子数组的和<br>2. 最长无重复子串<br>3. 最小覆盖子串<br>4. 定长区间的最大值|
|时间复杂度优化|通常从 O(n²) 优化到 O(n)|通常从 O(n²) 优化到 O(n)|
|空间复杂度|通常是 O(1)|可能需要额外空间来维护窗口信息，如哈希表|
|对数据顺序的要求|某些情况下需要排序（如两数之和）|通常不需要排序|

让我们通过代码来看一个具体的例子，说明它们的区别：

python

Copy

`# 双指针示例：两数之和（对撞双指针） def twoSum(arr, target):     left, right = 0, len(arr) - 1    while left < right:        current_sum = arr[left] + arr[right]        if current_sum == target:            return [left, right]        elif current_sum < target:            left += 1        else:            right -= 1    return [] # 滑动窗口示例：最大连续子数组和 def maxSubArraySum(arr, k):  # k是窗口大小     window_sum = sum(arr[:k])  # 初始窗口    max_sum = window_sum         # 窗口滑动    for i in range(k, len(arr)):        window_sum = window_sum + arr[i] - arr[i-k]  # 加入新元素，移除旧元素        max_sum = max(max_sum, window_sum)         return max_sum`

重要的区别在于：

1. 状态维护：
    - 滑动窗口通常需要维护窗口内的状态（如和、频率计数等）
    - 双指针通常只需要关注指针位置
2. 问题类型：
    - 滑动窗口适合处理需要考虑连续子序列的问题
    - 双指针可以处理更广泛的问题，包括不需要连续性的问题
3. 实现复杂度：
    - 滑动窗口通常需要更多的状态管理代码
    - 双指针实现往往更简单直接

你可以把滑动窗口想象成一个特殊的双指针技巧，就像正方形是特殊的长方形。它继承了双指针的基本特性，但有着自己的特殊约束和适用场景。

理解了这些区别后，你就能更好地判断在面对具体问题时应该使用哪种技术。比如，如果问题涉及连续子数组或子串，很可能应该使用滑动窗口；如果问题可以通过两个位置的配合来解决，但不需要考虑它们之间的连续性，那么普通的双指针可能更合适。

### 双指针
在数组的区间问题上，暴力算法的时间复杂度往往是 O(n2)O(n2)。而双指针利用了区间「单调性」的性质，可以将时间复杂度降到 O(n)O(n)。

### 滑动窗口
滑动窗口利用了双指针中的快慢指针技巧，我们可以将滑动窗口看做是快慢指针两个指针中间的区间，也可以将滑动窗口看做是快慢指针的一种特殊形式。

- **滑动操作**：窗口可按照一定方向进行移动。最常见的是向右侧移动。
- **缩放操作**：对于不定长度的窗口，可以从左侧缩小窗口长度，也可以从右侧增大窗口长度。
## [滑动窗口适用范围](https://algo.itcharge.cn/01.Array/05.Array-Sliding-Window/01.Array-Sliding-Window/#_2-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4)

滑动窗口算法一般用来解决一些查找满足一定条件的连续区间的性质（长度等）的问题。该算法可以将一部分问题中的嵌套循环转变为一个单循环，因此它可以减少时间复杂度。

- **固定长度窗口**：窗口大小是固定的。
- **不定长度窗口**：窗口大小是不固定的。
    - 求解最大的满足条件的窗口。
    - 求解最小的满足条件的窗口。

## #链表基础知识

**链表（Linked List）**：一种线性表数据结构。它使用一组任意的存储单元（可以是连续的，也可以是不连续的），来存储一组具有相同类型的数据。（python中的list不要求数据类型相同）

![[Pasted image 20250114171916.png]]
链表通过将一组任意的存储单元串联在一起。其中，每个数据元素占用若干存储单元的组合称为一个「链节点」。

为了将所有的节点串起来，每个链节点不仅要存放一个数据元素的值，还要存放一个指出这个数据元素在逻辑关系上的直接后继元素所在链节点的地址，该地址被称为「后继指针 next」。

- **优点**：存储空间不必事先分配，在需要存储空间的时候可以临时申请，不会造成空间的浪费；一些操作的时间效率远比数组高（插入、移动、删除元素等）。（**因为只需要update next pointer，而不需要shift）**
-  **缺点**：不仅数据元素本身的数据信息要占用存储空间，指针也需要占用存储空间，链表结构比数组结构的**空间开销大**。

![[Pasted image 20250114171922.png]]

**双向链表（Doubly Linked List）**：链表的一种，也叫做双链表。它的每个链节点中有两个指针，分别指向直接后继和直接前驱。

- **双向链表特点**：从双链表的任意一个节点开始，都可以很方便的访问它的前驱节点和后继节点。

**循环链表（Circular linked list）**：链表的一种。它的最后一个链节点指向头节点，形成一个环。
![[Pasted image 20250114172010.png]]
- **循环链表特点**：从循环链表的任何一个节点出发都能找到任何其他节点。
## [链表的基本操作](https://algo.itcharge.cn/02.Linked-List/01.Linked-List-Basic/01.Linked-List-Basic/#_2-%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C)

增、删、改、查 4 种情况

- **链节点类（即 ListNode 类）**：使用成员变量 valval 表示数据元素的值，使用指针变量 nextnext 表示后继指针。
    
- **链表类（即 LinkedList 类）**：使用一个链节点变量 headhead 来表示链表的头节点。


```
# 链节点类
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

# 链表类
class LinkedList:
    def __init__(self):
        self.head = None

```

在开头插入链表 - 顺序很关键！必须先让新node指向head，然后再把新node设置成head，不然会出现新node自己指向自己。

原始顺序：

```
new_node.next = self.head    # 1. 新节点指向原来的头节点
self.head = new_node        # 2. 头指针指向新节点
```
如果换成：
```
self.head = new_node        # 1. 头指针指向新节点
new_node.next = self.head    # 2. 新节点指向自己！这就出问题了
```
这就像你要在队伍前面插入一个新人：

1. 必须先让新人拉住原来第一个人的手
2. 再让队长拉住新人的手
3. 如果先让队长拉住新人，就会松开原来第一个人的手，整个队伍就断开了

所以顺序在这里是非常重要的，必须保持原有的顺序才能正确完成插入操作。

「求线性链表长度」的操作依赖于链表的链节点个数，操作的次数为 n，因此，「求线性链表长度」的时间复杂度为 O(n)，n为链表长度。

「在链表中查找值为 valval 的元素」的操作依赖于链表的链节点个数，因此，「在链表中查找值为 valval 的元素」的时间复杂度为 O(n)，n 为链表长度。

「链表头部插入元素」的操作与链表的长度无关，因此，「链表头部插入元素」的时间复杂度为 O(1)。
![[Pasted image 20250114194658.png]]

「链表尾部插入元素」的操作需要将 curcur 从链表头部移动到尾部，操作次数是 n 次，因此，「链表尾部插入元素」的时间复杂度是 O(n)。
![[Pasted image 20250114194712.png]]

「链表中间插入元素」的操作需要将 curcur 从链表头部移动到第 ii 个链节点之前，操作的平均时间复杂度是 O(n)，因此，「链表中间插入元素」的时间复杂度是 O(n)。
![[Pasted image 20250114194736.png]]
「将链表中第 ii 个元素值改为 valval」需要将 curcur 从链表头部移动到第 i 个链节点，操作的平均时间复杂度是 O(n)，因此，「将链表中第 i 个元素值改为 valval」的时间复杂度是 O(n)。

「链表头部删除元」只涉及到 1 步移动操作，因此，「链表头部删除元素」的时间复杂度为 O(1)。
![[Pasted image 20250114195009.png]]

**「链表尾部删除元素」的操作涉及到移动到链表尾部，操作次数为 n−2 次，因此，「链表尾部删除元素」的时间复杂度为 O(n)。**

![[Pasted image 20250114195046.png]]
「链表中间删除元素」的操作需要将 curcur 从链表头部移动到第 i 个链节点之前，操作的平均时间复杂度是 O(n)，因此，「链表中间删除元素」的时间复杂度是 O(n)。
![[Pasted image 20250114195231.png]]
## [链表总结](https://algo.itcharge.cn/02.Linked-List/01.Linked-List-Basic/01.Linked-List-Basic/#_3-%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93)

链表是最基础、最简单的数据结构。**「链表」** 是实现线性表的链式存储结构的基础。它使用一组任意的存储单元（可以是连续的，也可以是不连续的），来存储一组具有相同类型的数据。

**链表最大的优点在于可以灵活的添加和删除元素。**

- 链表进行访问元素、改变元素操作的时间复杂度为 O(n)。
- 链表进行头部插入、头部删除元素操作的时间复杂度是 O(1)。
- 链表进行尾部插入、尾部删除操作的时间复杂度是 O(n)。
- 链表在普通情况下进行插入、删除元素操作的时间复杂度为 O(n)。

**因为链表不支持随机访问**

#  链表双指针知识

**双指针（Two Pointers）**：指的是在遍历元素的过程中，不是使用单个指针进行访问，而是使用两个指针进行访问，从而达到相应的目的。如果两个指针方向相反，则称为「对撞时针」。如果两个指针方向相同，则称为「快慢指针」。如果两个指针分别属于不同的数组 / 链表，则称为「分离双指针」。

单链表中，因为遍历节点只能顺着 `next` 指针方向进行，所以对于链表而言，一般只会用到「快慢指针」和「分离双指针」。其中链表的「快慢指针」又分为「起点不一致的快慢指针」和「步长不一致的快慢指针」。

# 01. 堆栈基础知识

**堆栈（Stack）**：简称为栈。一种线性表数据结构，是一种只允许在表的一端进行插入和删除操作的线性表。
![[Pasted image 20250122142446.png]]
堆栈有两种基本操作：**「插入操作」** 和 **「删除操作」**。

- 栈的插入操作又称为「入栈」或者「进栈」。
- 栈的删除操作又称为「出栈」或者「退栈」。

简单来说，栈是一种 **「后进先出（Last In First Out）」** 的线性表，简称为 **「LIFO 结构」**。

我们可以从两个方面来解释一下栈的定义：

- 第一个方面是 **「线性表」**。

栈首先是一个线性表，栈中元素具有前驱后继的线性关系。栈中元素按照 a1,a2,...,ana1​,a2​,...,an​ 的次序依次进栈。栈顶元素为 anan​。

- 第二个方面是 **「后进先出原则」**。

根据堆栈的定义，每次删除的总是堆栈中当前的栈顶元素，即最后进入堆栈的元素。而在进栈时，最先进入堆栈的元素一定在栈底，最后进入堆栈的元素一定在栈顶。也就是说，元素进入堆栈或者退出退栈是按照「后进先出（Last In First Out）」的原则进行的。


## [堆栈的顺序存储与链式存储](https://algo.itcharge.cn/03.Stack/01.Stack-Basic/01.Stack-Basic/#_2-%E5%A0%86%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8)

和线性表类似，栈有两种存储表示方法：**「顺序栈」** 和 **「链式栈」**。

- **「顺序栈」**：即堆栈的顺序存储结构。利用一组地址连续的存储单元依次存放自栈底到栈顶的元素，同时使用指针 top 指示栈顶元素在顺序栈中的位置。
- **「链式栈」**：即堆栈的链式存储结构。利用单链表的方式来实现堆栈。栈中元素按照插入顺序依次插入到链表的第一个节点之前，并使用栈顶指针 top 指示栈顶元素，top 永远指向链表的头节点位置。

在描述堆栈的顺序存储与链式存储具体实现之前，我们先来看看堆栈具有哪些基本操作。

```
# 顺序栈实现
class SequentialStack:
    def __init__(self, size=100):
        self.stack = [None] * size  # 预分配固定大小的列表
        self.top = -1  # 栈顶指针，初始为-1表示空栈
        self.size = size
    
    def push(self, data):
        if self.top >= self.size - 1:
            raise Exception("栈满")
        self.top += 1
        self.stack[self.top] = data
    
    def pop(self):
        if self.top < 0:
            raise Exception("栈空")
        data = self.stack[self.top]
        self.top -= 1
        return data
    
    def is_empty(self):
        return self.top == -1

# 链式栈实现
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedStack:
    def __init__(self):
        self.top = None  # 栈顶指针，指向链表头节点
    
    def push(self, data):
        new_node = Node(data)
        new_node.next = self.top  # 新节点指向当前的栈顶
        self.top = new_node      # 更新栈顶为新节点
    
    def pop(self):
        if self.top is None:
            raise Exception("栈空")
        data = self.top.data
        self.top = self.top.next  # 栈顶指向下一个节点
        return data
    
    def is_empty(self):
        return self.top is None
```

**注意：在链式栈中，push的时候，我们并没有检查栈是否**满了

链式栈不需要检查"栈满"的原因是因为它使用的是动态内存分配的方式。只要系统的内存还有空间，我们就可以继续创建新的节点并压入栈中。

### [2.1 寻找左侧第一个比当前元素大的元素](https://algo.itcharge.cn/03.Stack/02.Monotone-Stack/01.Monotone-Stack/#_2-1-%E5%AF%BB%E6%89%BE%E5%B7%A6%E4%BE%A7%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AF%94%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0)

- 从左到右遍历元素，构造单调递增栈（从栈顶到栈底递增）：
    - 一个元素左侧第一个比它大的元素就是将其「插入单调递增栈」时的栈顶元素。
    - 如果插入时的栈为空，则说明左侧不存在比当前元素大的元素。

### [2.2 寻找左侧第一个比当前元素小的元素](https://algo.itcharge.cn/03.Stack/02.Monotone-Stack/01.Monotone-Stack/#_2-2-%E5%AF%BB%E6%89%BE%E5%B7%A6%E4%BE%A7%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AF%94%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0)

- 从左到右遍历元素，构造单调递减栈（从栈顶到栈底递减）：
    - 一个元素左侧第一个比它小的元素就是将其「插入单调递减栈」时的栈顶元素。
    - 如果插入时的栈为空，则说明左侧不存在比当前元素小的元素。

### [2.3 寻找右侧第一个比当前元素大的元素](https://algo.itcharge.cn/03.Stack/02.Monotone-Stack/01.Monotone-Stack/#_2-3-%E5%AF%BB%E6%89%BE%E5%8F%B3%E4%BE%A7%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AF%94%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0)

- 从左到右遍历元素，构造单调递增栈（从栈顶到栈底递增）：
    
    - 一个元素右侧第一个比它大的元素就是将其「弹出单调递增栈」时即将插入的元素。
    - 如果该元素没有被弹出栈，则说明右侧不存在比当前元素大的元素。
- 从右到左遍历元素，构造单调递增栈（从栈顶到栈底递增）：
    
    - 一个元素右侧第一个比它大的元素就是将其「插入单调递增栈」时的栈顶元素。
    - 如果插入时的栈为空，则说明右侧不存在比当前元素大的元素。

### [2.4 寻找右侧第一个比当前元素小的元素](https://algo.itcharge.cn/03.Stack/02.Monotone-Stack/01.Monotone-Stack/#_2-4-%E5%AF%BB%E6%89%BE%E5%8F%B3%E4%BE%A7%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AF%94%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0)

- 从左到右遍历元素，构造单调递减栈（从栈顶到栈底递减）：
    
    - 一个元素右侧第一个比它小的元素就是将其「弹出单调递减栈」时即将插入的元素。
    - 如果该元素没有被弹出栈，则说明右侧不存在比当前元素小的元素。
- 从右到左遍历元素，构造单调递减栈（从栈顶到栈底递减）：
    
    - 一个元素右侧第一个比它小的元素就是将其「插入单调递减栈」时的栈顶元素。
    - 如果插入时的栈为空，则说明右侧不存在比当前元素小的元素。

上边的分类解法有点绕口，可以简单记为以下条规则：

- 无论哪种题型，都建议从左到右遍历元素。
    
- 查找 **「比当前元素大的元素」** 就用 **单调递增栈**，查找 **「比当前元素小的元素」** 就用 **单调递减栈**。
    
- 从 **「左侧」** 查找就看 **「插入栈」** 时的栈顶元素，从 **「右侧」** 查找就看 **「弹出栈」** 时即将插入的元素。
- 

1. 选择单调栈类型的原因：

- 找"大元素"用递增栈：保证栈顶是可能成为其他元素"第一个大元素"的最小候选值
- 找"小元素"用递减栈：保证栈顶是可能成为其他元素"第一个小元素"的最大候选值

1. 查找方向的区别：

- 左侧查找：当前元素入栈时，栈顶元素就是左边第一个符合条件的元素。
	- 先通过栈顶和当前元素比较进行弹栈，然后决定是否存在符合条件的元素
	- 然后再入栈
- 右侧查找：当栈顶元素被弹出时，让它弹出的那个新元素就是右边第一个符合条件的元素


# 队列基础知识

**队列（Queue）**：一种线性表数据结构，是一种只允许在表的一端进行插入操作，而在表的另一端进行删除操作的线性表。

我们把队列中允许插入的一端称为 **「队尾（rear）」**；把允许删除的另一端称为 **「队头（front）」**。当表中没有任何数据元素时，称之为 **「空队」**。

队列有两种基本操作：**「插入操作」** 和 **「删除操作」**。

- 队列的插入操作又称为「入队」。
- 队列的删除操作又称为「出队」。

![队列结构](https://qcdn.itcharge.cn/images/202405092254785.png)

简单来说，队列是一种 **「先进先出（First In First Out）」** 的线性表，简称为 **「FIFO 结构」**。

我们可以从两个方面来解释一下队列的定义：

- 第一个方面是 **「线性表」**。

队列首先是一个线性表，队列中元素具有前驱后继的线性关系。队列中元素按照 a1,a2,...,ana1​,a2​,...,an​ 的次序依次入队。队头元素为 a1a1​，队尾元素为 an​。

- 第二个方面是 **「先进先出原则」**。

根据队列的定义，最先进入队列的元素在队头，最后进入队列的元素在队尾。每次从队列中删除的总是队头元素，即最先进入队列的元素。也就是说，元素进入队列或者退出队列是按照「先进先出（First In First Out）」的原则进行的。

和线性表类似，队列有两种存储表示方法：**「顺序存储的队列」** 和 **「链式存储的队列」**。

- **「顺序存储的队列」**：利用一组地址连续的存储单元依次存放队列中从队头到队尾的元素，同时使用**指针 front 指向队头元素在队列中的位置，使用指针 rear 指示队尾元素在队列中的位置**。
- **「链式存储的队列」**：利用单链表的方式来实现队列。队列中元素按照插入顺序依次插入到链表的第一个节点之后，**并使用队头指针 front 指向链表头节点位置，也就是队头元素，rear 指向链表尾部位置，也就是队尾元素**。

注意：front 和 rear 的指向位置并不完全固定。**有时候算法设计上的方便以及代码简洁，也会使 front 指向队头元素所在位置的前一个位置。rear 也可能指向队尾元素在队列位置的下一个位置。具体还是要看算法是如何实现的。**

在描述队列的顺序存储与链式存储具体实现之前，我们先来看看队列具有哪些基本操作。

### [2.1 队列的基本操作](https://algo.itcharge.cn/04.Queue/01.Queue-Basic/01.Queue-Basic/#_2-1-%E9%98%9F%E5%88%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C)

- **初始化空队列**：创建一个空队列，定义队列的大小 size，以及队头元素指针 front，队尾指针 rear。
    
- **判断队列是否为空**：当队列为空时，返回 True。当队列不为空时，返回 False。一般只用于「出队操作」和「获取队头元素操作」中。
    
- **判断队列是否已满**：当队列已满时，返回 True，当队列未满时，返回 False。一般只用于顺序队列中插入元素操作中。(只在使用list的时候)
    
- **插入元素（入队）**：相当于在线性表最后一个数据元素后面插入一个新的数据元素。并改变队尾指针 rearrear 的指向位置。
    
- **删除元素（出队）**：相当于在线性表中删除第一个数据元素。并改变队头指针 front 的指向位置。
    
- **获取队头元素**：相当于获取线性表中第一个数据元素。与插入元素（入队）、删除元素（出队）不同的是，该操作并不改变队头指针 frontfront 的指向位置。
    
- **获取队尾元素**：相当于获取线性表中最后一个数据元素。与插入元素（入队）、删除元素（出队）不同的是，该操作并不改变队尾指针 rearrear 的指向位置。
    

接下来我们来看一下队列的顺序存储与链式存储两种不同的实现方式。

```
class Queue:
    # 初始化空队列
    def __init__(self, size=100):
        self.size = size
        self.queue = [None for _ in range(size)]
        self.front = -1
        self.rear = -1
        
    # 判断队列是否为空
    def is_empty(self):
        return self.front == self.rear
    
    # 判断队列是否已满
    def is_full(self):
        return self.rear + 1 == self.size
    
    # 入队操作
    def enqueue(self, value):
        if self.is_full():
            raise Exception('Queue is full')
        else:
            self.rear += 1
            self.queue[self.rear] = value
            
    # 出队操作
    def dequeue(self):
        if self.is_empty():
            raise Exception('Queue is empty')
        else:
            self.front += 1
            return self.queue[self.front]
        
    # 获取队头元素
    def front_value(self):
        if self.is_empty():
            raise Exception('Queue is empty')
        else:
            return self.queue[self.front + 1]
    
    # 获取队尾元素
    def rear_value(self):
        if self.is_empty():
            raise Exception('Queue is empty')
        else:
            return self.queue[self.rear]

```

在「2.2 队列的顺序存储实现」中，如果队列中第 0 ~ size−1 位置均被队列元素占用时，此时队列已满（即 self.rear==self.size−1），再进行入队操作就会抛出队列已满的异常。

而由于出队操作总是删除当前的队头元素，将 self.frontself.front 进行右移，而插入操作又总是在队尾进行。经过不断的出队、入队操作，队列的变化就像是使队列整体向右移动。

当队尾指针满足 self.rear == self.size−1 条件时，此时再进行入队操作就会抛出队列已满的异常。而之前因为出队操作而产生空余位置也没有利用上，这就造成了「假溢出」问题。

为了解决「假溢出」问题，有两种做法：

- 第一种：每一次删除队头元素之后，就将整个队列往前移动 11 个位置。其代码如下所示：
```
# 出队操作
def dequeue(self):
    if self.is_empty():
        raise Exception('Queue is empty')
    else:
        value = self.queue[0]
        for i in range(self.rear):
            self.queue[i] = self.queue[i + 1]
        return value

```
这种情况下，队头指针似乎用不到了。因为队头指针总是在队列的第 0 个位置。但是因为删除操作涉及到整个队列元素的移动，所以每次删除操作的时间复杂度就从 O(1) 变为了 O(n)。所以这种方式不太可取。

# 优先队列知识

**优先队列（Priority Queue）**：一种特殊的队列。在优先队列中，元素被赋予优先级，当访问队列元素时，具有最高优先级的元素最先删除。


# 01. 树与二叉树的基础知识

**树（Tree）**：由 n≥0n≥0 个节点与节点之间的关系组成的有限集合。当 n=0n=0 时称为空树，当 n>0n>0 时称为非空树。

### 二叉树与二叉堆的关系
1. 基本概念对比：

- 二叉树：每个节点最多有两个子节点的树形结构
- 完全二叉树：除了最后一层，其他层的节点都是满的，且最后一层的节点都靠左排列
- 二叉堆：在完全二叉树的基础上增加了堆属性（节点值的大小关系）

2. 二叉堆的两种类型：

大顶堆：

```
       50
     /    \
   30      20
  /  \    /
10   15  5
```

特点：每个父节点的值都大于或等于其子节点的值 用途：

- 实现优先队列（找最大值）
- 堆排序（从小到大排序）
- 获取数据流中的最大值

小顶堆：
```
       5
     /   \
   15    10
  /  \   /
30   20 25
```

特点：每个父节点的值都小于或等于其子节点的值 用途：

- 实现优先队列（找最小值）
- 堆排序（从大到小排序）
- 获取数据流中的最小值

###  二叉堆与普通二叉树，搜索二叉树的概念和区别：
![[Pasted image 20250126115536.png]]

二叉树（Binary Tree）- 最基础的概念
```

    A
   / \
  B   C
 /     \
D       E
```

定义：每个节点最多有两个子节点的树结构 特点：

- 节点间没有特定的大小关系
- 形状可以任意
- 适用于表达具有层级关系的数据

二叉搜索树（Binary Search Tree, BST）- 有序的二叉树

定义：一种特殊的二叉树，满足：
```
    8
   / \
  3   10
 / \    \
1   6    14

```

- 左子树的所有节点值都小于根节点
- 右子树的所有节点值都大于根节点
- 左右子树也都是二叉搜索树 特点：
- 中序遍历得到升序序列
- 查找效率为 O(log n)
- 适用于需要频繁查找、插入、删除的场景

- 二叉树（Binary Tree）
    - 定义：每个节点最多有两个子节点的树形数据结构
    - 特点：没有任何节点值或结构的限制，可以是任意形态
    - 表现形式：可以是对称的，也可以是不对称的，可以是稀疏的，也可以是密集的
    - 主要用途：表示具有层次关系的数据结构，如文件系统的目录结构
- 完全二叉树（Complete Binary Tree）
    - 定义：除了最后一层，其他层的节点都是满的，且最后一层的节点都靠左排列
    - 特点：适合用数组存储，因为节点的位置和数组索引有直接对应关系
    - 表现形式：像金字塔一样从上到下、从左到右填充
    - 主要用途：作为实现二叉堆的基础结构，高效的数组存储
- 二叉搜索树（Binary Search Tree）
    - 定义：左子树所有节点的值小于根节点，右子树所有节点的值大于根节点
    - 特点：中序遍历会得到一个有序序列，查找效率高
    - 表现形式：节点按大小有序分布，左小右大
    - 主要用途：数据的快速查找、插入和删除，维护有序数据集合
- 二叉堆（Binary Heap）
    - 定义：一个完全二叉树，同时满足堆属性（父节点与子节点的大小关系）
    - 特点：
        - 大顶堆：父节点值大于等于子节点值
        - 小顶堆：父节点值小于等于子节点值
    - 表现形式：树的形状必须是完全二叉树，节点值满足父子大小关系
    - 主要用途：实现优先队列，获取最值操作

**1. 时间复杂度比较**

|操作|二叉树|完全二叉树|二叉搜索树|二叉堆|
|---|---|---|---|---|
|查找特定值|O(n)|O(n)|O(log n)*|O(n)|
|插入|O(1)|O(1)|O(log n)*|O(log n)|
|删除|O(1)|O(1)|O(log n)*|O(log n)|
|获取最值|O(n)|O(n)|O(log n)*|O(1)|
|中序遍历|O(n)|O(n)|O(n)|O(n)|

*注：二叉搜索树的性能假设树是平衡的，如果不平衡可能退化到 O(n)

**2. 概念关系对比**

|树类型|结构要求|节点值要求|平衡要求|
|---|---|---|---|
|二叉树|每个节点最多两个子节点|无要求|无要求|
|完全二叉树|除最后层外必须填满，最后层从左到右填充|无要求|自然平衡|
|二叉搜索树|每个节点最多两个子节点|左子树 < 根 < 右子树|最好平衡*|
|二叉堆|完全二叉树结构|父节点与子节点有大小关系|自然平衡|

*注：虽然不强制要求平衡，但通常会通过平衡来优化性能

**3. 典型使用场景**

| 树类型   | 最佳使用场景      | 实际应用例子             |
| ----- | ----------- | ------------------ |
| 二叉树   | 表示层次结构      | 文件系统、组织架构          |
| 完全二叉树 | 需要紧凑存储的场景   | 作为其他数据结构的基础（如堆）    |
| 二叉搜索树 | 需要快速查找和保持有序 | 数据库索引、文件系统搜索       |
| 二叉堆   | 需要快速获取最值    | 优先队列、任务调度、Top K 问题 |